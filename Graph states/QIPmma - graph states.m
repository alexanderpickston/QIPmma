(* ::Package:: *)

BeginPackage["GraphStates`"]


ClusterGenerator::usage = "Generates the graph state given by a graph.\nClusterGenerator[graph]"
FindLUequivalent::usage = "Find LC-equivalent applied on one vertex.\nFindLUequivalent[graph,vertex]"
LUfamily::usage = "Find a group of states LC-equivalent.\nNOTE: It might not be all the orbit.\nLUfamily[graph]"
LUfamilyISO::usage = "Select only the isomorphic graphs in LC-equivalent.\nLUfamilyISO[graph,vertex]"
Zmeasurement::usage ="Single Z-measurement\nZmeasurement[graph,vertex]"
FindSGroupXZSymbolic::usage = "Find the stabilizers generated by {\[DoubleStruckCapitalI],X,Z,-Z}.\nFindSGroupXZSymbolic[state]"
FindGraphFromXZStab::usage = "Given a list of X,Z stabilizers, apply all combinantions of {Hada, \[DoubleStruckCapitalI]} and select only those in the graph form i.e. one X per vertex\nFindGraphFromXZStab[state]"
DrawGraphFromStab::usage = "Drawn a graph given a list of stabilizers in the graph form i.e. one X per vertex\nDrawGraphFromStab[stabilizersList]"
Xmeasurement::usage = "Single X measurement on a graph vertex.\nXmeasurement[graph,vertex]"
Ymeasurement::usage = "Single Y measurement on a graph vertex.\nYmeasurement[graph,vertex]"
Zmeasurement::usage = "Single Z measurement on a graph vertex.\nZmeasurement[graph,vertex]"
CustomGraphStyle::usage = "Custom graph styling using the circular embedding layout argument. Usage: \nCustomGraphStyle[graph]"


Begin["`Private`"]


(* List of rules for the application of the Pauli matrices to vector states used in the FindSGroupXZSymbolic function *)
operationrules={

s0[qubit_]->{{H[qubit]->H[qubit],V[qubit]->V[qubit]}},
sx[qubit_]->{{H[qubit]->V[qubit],V[qubit]->H[qubit]}},
-sx[qubit_]->{{H[qubit]->-V[qubit],V[qubit]->-H[qubit]}},
s0*sx[qubit_]->{{H[qubit]->I*V[qubit],V[qubit]->I*H[qubit]}},
-s0*sx[qubit_]->{{H[qubit]->-I*V[qubit],V[qubit]->-I*H[qubit]}},
sz[qubit_]->{{H[qubit]->H[qubit],V[qubit]->-V[qubit]}},
-sz[qubit_]->{{H[qubit]->-H[qubit],V[qubit]->V[qubit]}},
s0*sz[qubit_]->{{H[qubit]->I*H[qubit],V[qubit]->-I*V[qubit]}},
-s0*sz[qubit_]->{{H[qubit]->I*H[qubit],V[qubit]->-I*V[qubit]}},
sy[qubit_]->{{H[qubit]->I*V[qubit],V[qubit]->-I*H[qubit]}},
-sy[qubit_]->{{H[qubit]->-I*V[qubit],V[qubit]->I*H[qubit]}},
s0*sy[qubit_]->{{H[qubit]->-V[qubit],V[qubit]->H[qubit]}},
-s0*sy[qubit_]->{{H[qubit]->V[qubit],V[qubit]->-H[qubit]}}

};

(* projectors |0x0| and |1x1| *)
project00 = {{1,0},{0,0}};
project11 = {{0,0},{0,1}};

(* graph styling *)
graphstyle={
VertexSize->{0.4},
VertexLabels->{Placed["Name",{1/2*1.05,1/2*1.05}]},
ImageSize->{146.99479166666538,Automatic},
VertexStyle->{Directive[EdgeForm[{Thick,Opacity[1],Blue}],Blue]},
VertexLabelStyle->Directive[White,FontFamily->"IBM Plex Mono",20],
EdgeStyle->Directive[Black,Thick,Opacity[1]],
GraphLayout->"CircularEmbedding"
};


(* custom graph style for univeral usage throught library *)

CustomGraphStyle[graph_]:=Graph[graph,graphstyle];


(* generates a list of idn matrices and replace the projectors in the control and target position *)
(* then apply the kron to get the CZ matrix *)

CZ[control_,target_,nqubits_]:=(
Kron@@(ReplacePart[Table[s0,{nqubits}],control-> project00])+Kron@@(ReplacePart[Table[s0,{nqubits}],{control-> project11,target-> sz}])
);


Module[{subGraph,diffGraph,complementGraph,out},

QubitLC[graph_,vertex_]:=(

(* Select the subgraph generated by the vertex and its neighbours *)
subGraph=Subgraph[graph,AdjacencyList[graph,vertex]];
(* Complement the sub graph *)
complementGraph=GraphComplement[subGraph];
(* remove the starting subgraph *)
diffGraph=GraphDifference[graph,subGraph];
(* Union the new subGraph with the remaining main graph *)
out=GraphUnion[diffGraph,complementGraph];
out=Graph[out,graphstyle];
(* return the LC-equivalent graph *)
Return[out];);];


Module[{perm,prmList,noDuplicates},
LUfamily[graph_]:=(
perm=Permutations[Range[VertexCount[graph]],VertexCount[graph]];
prmList=FoldList[FindLUequivalent,graph,#]&/@perm//Flatten;
noDuplicates=DeleteDuplicates[prmList,IsomorphicGraphQ];
Return[noDuplicates];)];


Module[{perm,prmList,noDuplicates},
LUfamilyISO[graph_]:=(
perm=Permutations[Range[VertexCount[graph]],VertexCount[graph]];
prmList=FoldList[FindLUequivalent,graph,#]&/@perm//Flatten;
noDuplicates=Select[prmList,IsomorphicGraphQ[#,graph]&];
Return[noDuplicates];)];


Module[{edgeDelete},
Zmeasurement[graph_,vertex_]:=(
edgeDelete=Complement[EdgeList[graph],EdgeList[graph,vertex\[UndirectedEdge]_]];
Return[Graph[edgeDelete,

VertexShapeFunction->"Circle",
VertexSize->0.4,
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

]];
);
];


Module[{dim,ops,opsList,coding,codingState,allStates,pos},
FindSGroupXZSymbolic[state_]:=(
dim=1/Log[Length[state],2];
ops=Tuples[Table[{\[DoubleStruckCapitalI][i],X[i],Z[i],-Z[i]},{i,1,dim}]];
opsList=Flatten[#/.operationrules]&/@ops;
coding=kron@@Table[{H[i],V[i]},{i,1,dim}]//Flatten;
codingState=Total[state*coding];
allStates=codingState/.#&/@opsList;
pos=Position[#==(codingState)&/@allStates,True]//Flatten;
Return[ops[[pos]]])
];


Module[{dim,listStab,comb,cliffOp,combCliff,stabComb,graphGen,noSameNodeList,posStab,graphList},
FindGraphFromXZStab[state_]:=(
(* compute dimension of the input state *)
dim=1/Log[Length[state],2];
(* call function FindSGroupXZSymbolic to get a list of stabilizers from all comb of I,X,Z and -Z*)
(* As the phase -Z does not matter for finding the graph state, remove it *)
(* e.g. -Z,I and Z,I stabilize two different states but the same graph state *)
(* note that the ideal routine would be to find only the stabilizer generators, still open problem *)
listStab=Union[FindSGroupXZSymbolic[state]/.{-Z[qubit_]->Z[qubit]}];
(* consider all combinations of hadamard and Identity, should be enought... *)
comb=Tuples[{Table[HADA[i],{i,dim}],Table[ID[i],{i,dim}](*,Table[PH[i],{i,dim}]*)}\[Transpose]];
(* set the replacement rules *)
cliffOp={
HADA[qubit_]->{\[DoubleStruckCapitalI][qubit]->\[DoubleStruckCapitalI][qubit],X[qubit]->Z[qubit],Y[qubit]->Y[qubit],Z[qubit]->X[qubit]},
(*PH[qubit_]\[Rule]{\[DoubleStruckCapitalI][qubit]->\[DoubleStruckCapitalI][qubit],X[qubit]\[Rule]Y[qubit],Y[qubit]\[Rule]X[qubit],Z[qubit]\[Rule]Z[qubit]},*)
ID[qubit_]->{\[DoubleStruckCapitalI][qubit]->\[DoubleStruckCapitalI][qubit],X[qubit]->X[qubit],Y[qubit]->Y[qubit],Z[qubit]->Z[qubit]}};
(* take the first half of all the comb ;;2^(dim-1) and replace comb with a list of rules *)
(* the second half is symmetric and will give the same results *)
combCliff=Flatten[#]&/@(comb[[;;(2^(dim-1))]]/.cliffOp);
(* apply the rules on the stabilizers *)
stabComb=listStab/.combCliff;
(* select only those with one X per group of stabilizers *)
graphGen=Select[
Select[#,Count[#,X[_]]==1&]&/@stabComb,
Length@#>=dim&];
(* select only those with an X per node *)
noSameNodeList=Table[
Count[graphGen[[el]],#]&/@Table[{___,X[i],___},{i,1,dim}],
{el,Length@graphGen}];
(* find thir positions *)
posStab=Position[noSameNodeList,Table[1,dim]];
(* return the list *)
graphList=graphGen[[#]]&/@posStab;
Return[Flatten[graphList,1]])
];


Module[{linkList,nodeList,toGraph,noDoubleLinks},
DrawGraphFromStab[stabList_]:=(
linkList=Flatten[#]&/@(Position[#,Z[_]]&/@stabList);
nodeList=Flatten[(Position[#,X[_]]&/@stabList)];
toGraph=Table[
nodeList[[i]]\[UndirectedEdge]#&/@linkList[[i]],
{i,Length@nodeList}];
noDoubleLinks=DeleteDuplicates[Flatten[toGraph],#1==Reverse[#2]&];
Return[Graph[noDoubleLinks,

VertexShapeFunction->"Circle",
VertexSize->0.4,
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

]])
];


Module[{edgeDelete},
Zmeasurement[graph_,vertex_]:=(
edgeDelete=Complement[EdgeList[graph],EdgeList[graph,vertex\[UndirectedEdge]_]];
Return[Graph[edgeDelete,

VertexShapeFunction->"Circle",
VertexSize->0.4,
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

]];
);
];


Ymeasurement[graph_,vertex_]:=(
Return[
Zmeasurement[
FindLUequivalent[graph,vertex],vertex]]);


Module[{randomNeighbour,tempGraph},
Xmeasurement[graph_,vertex_]:=(
randomNeighbour=RandomChoice@AdjacencyList[graph,vertex];
tempGraph=Ymeasurement[FindLUequivalent[graph,randomNeighbour],vertex];

Return[
FindLUequivalent[tempGraph,randomNeighbour]]);
];



userColor = Lighter@Gray;
networkColor = White;

CustomGraphStyleNetwork[graph_]:= Graph[graph, VertexStyle -> {
    1 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    2 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    5 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    6 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    4 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], networkColor],
    3 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], networkColor]},
VertexLabelStyle -> Directive[Black, FontFamily -> "IBM Plex Serif", 25],
EdgeStyle -> Directive[Black, Thick, Opacity[1]],
GraphLayout -> "CircularEmbedding"];


End[]


EndPackage[]
